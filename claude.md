# Powerhouse Document Models Assistant

This project creates document models, editors, processors and subgraphs for the Powerhouse ecosystem. Your role is to help users create these modules based on their needs.

## Core Concepts

- **Document Model**: A template for creating documents. Defines schema and allowed operations for a document type.
- **Document**: An instance of a document model containing actual data that follows the model's structure and can be modified using operations.
- **Drive**: A document of type "powerhouse/document-drive" representing a collection of documents and folders. Add documents using "addActions" with "ADD_FILE" action.
- **Action**: A proposed change to a document (JSON object with action name and input). Dispatch using "addActions" tool.
- **Operation**: A completed change to a document containing the action plus metadata (index, timestamp, hash, errors). Actions become operations after dispatch.

## CRITICAL: MCP Tool Usage Rules

**MANDATORY**: The `reactor-mcp` MUST BE USED when handling documents or document-models for the Powerhouse/Vetra ecosystem.
If the `reactor-mcp` server is unavailable, ask the user to run `ph vetra` on a separate terminal to start the server and try to reconnect to the MCP server, DO NOT run it yourself.

### Key Requirements:

- Never set document IDs manually - they're auto-generated by 'createDocument'
- Minimize "addActions" calls by batching multiple actions together
- Add new document model documents to "vetra" drive unless specified otherwise
- Always check document model schema before calling addActions
- Use MCP tools for ALL document and document-model operations

## Document Model Creation Workflow

### 1. Planning Phase

**MANDATORY**: Present your proposal to the user and ask for confirmation before implementing ANY document model.

- **ALWAYS** describe the proposed document model structure (state schema, operations, modules) before creating
- **NEVER** proceed with implementation without explicit user approval of your proposal
- When in doubt, ask for clarification
- Break complex models into logical modules and operations

### 2. Pre-Implementation Requirements

**MANDATORY**: Check document model schema before making any MCP tool calls.

- **ALWAYS** use `mcp__reactor-mcp__getDocumentModelSchema` with `type: "powerhouse/document-model"` first
- Review input schema requirements for operations like `ADD_MODULE`, `ADD_OPERATION`, etc.
- Ensure all required parameters (like `id` or `scope` fields) are included in action inputs
- This prevents failed tool calls and reduces iteration

### 3. Implementation Requirements

- Document model reducers must be **pure synchronous functions**
- Reducers receive current state and operation, always returning the same result
- Values like dates/IDs must come from operation input, not generated in reducer
- Reducer code goes into SET_OPERATION_REDUCER action (no function header needed)
- Reducers are wrapped with Mutative - you can mutate the state object directly
- External imports go at the beginning of the actual reducer file in `src/`
- Ensure that the reducer code of each operation in the document model schema is applied in `document-models/<document-model-name>/src/reducers/<module-name>.ts`

### 4. Quality assurance

After doing changes to the code, or after creating a new document model or a new editor, _YOU MUST RUN_ the following commands to check for errors in your implementation:

- **TypeScript Check**: Run `npm run typecheck` to validate type safety
- **ESLint Check**: Run `npm run lint:fix` to check for errors with ESLint

## Document editor creation flow

When the user requests to create or make changes on a document editor, follow these steps:

- Check if the document editor already exists and if it does, ask the user if a new one should be created or if the existing one should be reimplemented
- If it's a new editor, create a new editor document on the "vetra" drive if available, of type `powerhouse/document-editor`
- Check the document editor schema and comply with it
- After adding the editor document to the `vetra` drive, a new editor will be generated in the `editors` folder
- Read the schema of the document model that the editor is for to know how to interact with it
- Style the editor using tailwind classes or a style tag. If using a style tag, make sure to make the selectors specific to only apply to the editor component.
- Create modular components for the UI elements and place them on separate files to make it easier to maintain and update
- Consider using the React Components exported by `@powerhousedao/design-system` and `@powerhousedao/document-engineering`
- Separate business logic from presentation logic
- Use TypeScript for type safety, avoid using any and type casting
- Always check for type and lint errors after creating or modifying the editor

## ⚠️ CRITICAL: Generated Files & Modification Rules

### Generated Files Rule

**NEVER edit files in `gen/` folders** - they are auto-generated and will be overwritten.

### Document Model Modification Process

For ANY document model changes, follow this **mandatory** two-step process:

#### Step 1: Update Document Model via MCP

Use `mcp__reactor-mcp__addActions` with operations like:

- `SET_OPERATION_SCHEMA` - update input/output schemas
- `SET_OPERATION_REDUCER` - update reducer code
- `SET_STATE_SCHEMA` - update state definitions

#### Step 2: Update Existing Source Files

**ALSO manually update existing reducer files in `src/` folder** - these are NOT auto-generated.
Make sure to check if the operation reducer code needs to be updated after changing the state schema.

### ⚠️ Critical Reminder

**ALWAYS do BOTH steps when fixing reducer issues:**

1. ✅ Fix existing reducer files in `src/` manually
2. ✅ Update document model via MCP with same fixes

**Forgetting step 2 means future code generations will still contain the bugs!**

## Reducer Implementation Guidelines

### ❌ Forbidden in Reducers (Non-Deterministic)

- `crypto.randomUUID()`, `Math.random()`, `Date.now()`, `new Date()`
- External API calls or side effects
- Asynchronous functions
- Any non-deterministic functions

### ❌ Forbidden Patterns

```typescript
// NEVER use fallback values with non-deterministic functions
id: action.input.id || crypto.randomUUID(); // ❌ FORBIDDEN
timestamp: action.input.timestamp || new Date(); // ❌ FORBIDDEN
```

### ✅ Required Pattern

All dynamic values must come from action input:

- **IDs**: Include `id: OID!` in input schema, use `action.input.id` in reducer
- **Timestamps**: Include `timestamp: DateTime!` in input schema
- **Computed values**: Calculate before dispatching action

### Example

```typescript
// ❌ BAD - impure reducer
const newItem = {
  id: crypto.randomUUID(), // Non-deterministic
  createdAt: new Date(), // Non-deterministic
};

// ✅ GOOD - pure reducer
const newItem = {
  id: action.input.id, // From action input
  createdAt: action.input.createdAt, // From action input
};
```

### Handling Nullable Input Types

**CRITICAL**: Be careful when handling optional input types:

- Optional input types use `InputMaybe<T>` allowing `null | undefined | T`.
- Optional state types use `Maybe<T>` = `T | null`.
- If there is no applicable default value then use `|| null`.

```typescript
// ❌ BAD - Type error with Maybe<string>
amount: action.input.amount,
notes: action.input.notes,

// ✅ GOOD - Matches Maybe<T> = T | null
amount: action.input.amount || null,
notes: action.input.notes || [],
```

Use truthy checks when conditionally assigning optional values from input to state:

```typescript
// ❌ BAD - Type 'string | null' is not assignable to type 'string'.
if (action.input.field !== undefined) entry.field = action.input.field;

// ✅ GOOD - use truthy checks
if (action.input.field) state.field = action.input.field;

// ✅ GOOD - For booleans use explicit null/undefined checks
if (action.input.field !== undefined && action.input.field !== null)
  state.field = action.input.field;
```

### Error Handling in Operations

**MANDATORY**: Define specific error types for each operation to handle invalid inputs and edge cases properly.
Action inputs are validated so they are guaranteed to respect the input schema.
Errors referenced in the reducer code will be imported automatically.

#### Error Definition Requirements

1. **Add error definitions** to operations using `ADD_OPERATION_ERROR`:

   - `code`: Uppercase snake_case (e.g., `"MISSING_ID"`, `"ENTRY_NOT_FOUND"`)
   - `name`: PascalCase ending with "Error" (e.g., `"MissingIdError"`, `"EntryNotFoundError"`)
   - `description`: Human-readable description of the error condition

2. **Error names must end with "Error"** for consistency and code generation

3. **Use specific error types** rather than generic validation

4. **Must use unique error names and ids**

#### Error Usage in Reducers

```typescript
// ✅ GOOD - Throw specific errors by name
if (!action.input.id) {
  throw new MissingIdError("ID is required for operation");
}

if (entryIndex === -1) {
  throw new EntryNotFoundError(`Entry with ID ${action.input.id} not found`);
}

// ❌ BAD - Generic Error
throw new Error("Something went wrong");

// ❌ BAD - Nested error access
throw new errors.ModuleName.MissingIdError("message");

// ❌ BAD - Do not import error classes in the reducer code,
import { MissingIdError } from "../../gen/module-name/error.js";

// ✅ GOOD - Simply reference the error and it will be imported automatically
throw new MissingIdError("message");
```

#### Common Error Patterns

- **EntityNotFoundError**: Referenced entity doesn't exist
- **DuplicateIdError**: ID already exists when creating new entries
- **InvalidInputError**: Business logic violations
- **PermissionDeniedError**: Access control violations

## Document Model Structure

### Core Components

- **Basic Metadata**: `id`, `name`, `extension`, `description`, `author` (name + website)
- **Specifications**: Versioned specs with `version`, `changeLog`, `state` (global/local with schema, initialValue, examples)
- **Modules**: Operational modules containing their operations

## Available Document Model Operations (37 total)

| Category                         | Operations                                                                                                                                                                                                       | Count |
| -------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----- |
| **Header Management**            | `SET_MODEL_NAME`, `SET_MODEL_ID`, `SET_MODEL_EXTENSION`, `SET_MODEL_DESCRIPTION`, `SET_AUTHOR_NAME`, `SET_AUTHOR_WEBSITE`                                                                                        | 6     |
| **Versioning**                   | ⚠️ **DO NOT USE** - Not implemented                                                                                                                                                                              | 0     |
| **Module Management**            | `ADD_MODULE`, `SET_MODULE_NAME`, `SET_MODULE_DESCRIPTION`, `DELETE_MODULE`, `REORDER_MODULES`                                                                                                                    | 5     |
| **Operation Management**         | `ADD_OPERATION`, `SET_OPERATION_NAME`, `SET_OPERATION_SCHEMA`, `SET_OPERATION_DESCRIPTION`, `SET_OPERATION_TEMPLATE`, `SET_OPERATION_REDUCER`, `MOVE_OPERATION`, `DELETE_OPERATION`, `REORDER_MODULE_OPERATIONS` | 9     |
| **Operation Error Management**   | `ADD_OPERATION_ERROR`, `SET_OPERATION_ERROR_CODE`, `SET_OPERATION_ERROR_NAME`, `SET_OPERATION_ERROR_DESCRIPTION`, `SET_OPERATION_ERROR_TEMPLATE`, `DELETE_OPERATION_ERROR`, `REORDER_OPERATION_ERRORS`           | 7     |
| **Operation Example Management** | `ADD_OPERATION_EXAMPLE`, `UPDATE_OPERATION_EXAMPLE`, `DELETE_OPERATION_EXAMPLE`, `REORDER_OPERATION_EXAMPLES`                                                                                                    | 4     |
| **State Management**             | `SET_STATE_SCHEMA`, `SET_INITIAL_STATE`, `ADD_STATE_EXAMPLE`, `UPDATE_STATE_EXAMPLE`, `DELETE_STATE_EXAMPLE`, `REORDER_STATE_EXAMPLES`                                                                           | 6     |

## Best Practices & Design Principles

### Scope Selection

- **`scope: "global"`**: State shared among all users with document access
- **`scope: "local"`**: State private to each individual user

### Operation Design

- Use descriptive operation names (e.g., `ADD_LINE_ITEM`, `UPDATE_RECIPIENT`)
- One operation per user intent (separate concerns)
- Include comprehensive examples and error definitions
- Organize related operations into logical modules

## GraphQL Schema Guidelines

### Document State Schema

- **Most fields optional** to support creating empty documents
- Use required fields `!` only when absolutely necessary
- Defaults handled by operations, not schema

### Available Scalar Types

| Standard  | Custom Identity        | Custom Amounts      | Custom Specialized |
| --------- | ---------------------- | ------------------- | ------------------ |
| `String`  | `OID` (Object ID)      | `Amount`            | `EthereumAddress`  |
| `Int`     | `PHID` (Powerhouse ID) | `Amount_Tokens`     | `EmailAddress`     |
| `Float`   | `OLabel`               | `Amount_Money`      | `Date`             |
| `Boolean` |                        | `Amount_Fiat`       | `DateTime`         |
|           |                        | `Amount_Currency`   | `URL`              |
|           |                        | `Amount_Crypto`     | `Currency`         |
|           |                        | `Amount_Percentage` |                    |

### Arrays and Objects

- **Arrays**: Must be mandatory `[ObjectType!]!`
- **Objects in arrays**: Must include `OID!` field for unique identification
- Include `OLabel` for metadata when relevant

### Input Types

- Reflect user intent with descriptive names
- Simple, specific fields over complex nested types
- System auto-generates `OID` for new objects (users don't provide manually)


## UI Component Guidelines

### Core UI Libraries

**MANDATORY**: Use the following Powerhouse UI libraries for all editor components:

- **Primary Components**: `@powerhousedao/document-engineering` for core UI elements
  - Forms: `TextInput`, `Textarea`, `Select`
  - Tables: `ObjectSetTable`, `ColumnDef`, `ColumnAlignment`
  - Navigation: `SidebarProvider`, `Sidebar`, `useSidebar`
  - Layouts: `Icon` (document-engineering variant)

- **Design System**: `@powerhousedao/design-system` for design consistency
  - Icons: `Icon` (design-system variant)
  - Buttons: `Button`
  - Toast: `toast`, `ToastContainer`
  - Other design system components

### Styling Requirements

**MANDATORY**: Follow TailwindCSS ^4.1.4 styling patterns:

- **Inline Styling**: Apply CSS styles inline using `className` prop
- **No External CSS**: Avoid creating separate CSS files for component-specific styles
- **Responsive Design**: Use Tailwind responsive utilities (`sm:`, `md:`, `lg:`, etc.)
- **Dark Mode**: Support dark mode using `.dark` class variant

### Component Architecture Patterns

**MANDATORY**: Follow these architectural patterns when building UI components:

#### Table Components
- Use `ObjectSetTable` for data display with editable cells
- Define column configurations using `ColumnDef<T>` with proper typing
- Implement `onSave`, `onAdd`, and `onDelete` handlers for data operations
- Use `renderCell` for custom cell rendering with business logic

```typescript
const columns = useMemo<Array<ColumnDef<T>>>(
  () => [
    {
      field: "fieldName",
      title: "Display Title",
      editable: true,
      align: "left" as ColumnAlignment,
      onSave: (newValue, context) => {
        // Handle save operation
        dispatch(actions.updateEntity({ id: context.row.id, field: newValue }));
        return true;
      },
    },
  ],
  []
);
```

#### Form Components
- Use `TextInput`, `Textarea`, and `Select` from document-engineering
- Implement `onBlur` handlers for auto-save functionality
- Use `defaultValue` for initial values, not `value` for uncontrolled components
- Include proper labels and validation feedback

```typescript
<TextInput
  className="w-full"
  label="Field Label"
  defaultValue={state.fieldValue}
  onBlur={(e) => {
    if (e.target.value !== state.fieldValue) {
      dispatch(actions.updateField({ field: e.target.value }));
    }
  }}
/>
```

#### Select Component Usage
**MANDATORY**: Use the `Select` component from `@powerhousedao/document-engineering` for dropdown selections:

```typescript
<Select
  label="Field Label"
  options={[
    { label: "Option 1", value: "OPTION_1" },
    { label: "Option 2", value: "OPTION_2" },
    { label: "Option 3", value: "OPTION_3" },
  ]}
  value={state.fieldValue}
  onChange={(value) => {
    dispatch(actions.updateField({ field: value as FieldType }));
  }}
/>
```

**Key Select Component Properties:**
- **`label`**: String - The field label displayed above the select
- **`options`**: Array of `{ label: string, value: string }` - Dropdown options
- **`value`**: String - Currently selected value from state
- **`onChange`**: Function - Handler that receives the selected value
- **No external wrapper needed** - Component includes its own label and styling

#### Navigation Components
- Use `SidebarProvider` and `Sidebar` for hierarchical navigation
- Implement breadcrumb navigation for deep navigation paths
- Use `useSidebar` hook for sidebar state management
- Support collapsible sidebar with width tracking

### Icon Usage

**MANDATORY**: Use appropriate icon sources:

- **Document Operations**: Use `Icon` from `@powerhousedao/document-engineering`
- **UI Elements**: Use `Icon` from `@powerhousedao/design-system`
- **Interactive Icons**: Include `onClick` handlers and hover states
- **Accessibility**: Provide proper `aria-label` attributes for icon buttons

### State Management Integration

**MANDATORY**: Integrate UI components with document state:

- **Dispatch Actions**: Use document model actions for all state changes
- **State Binding**: Connect component state to document global state
- **Real-time Updates**: Use `useEffect` and `useMemo` for reactive updates
- **ID Generation**: Use `generateId()` from document-model for new entities

### Responsive Design Patterns

**MANDATORY**: Implement responsive behavior:

- **Sidebar Adaptation**: Support collapsible sidebar with dynamic width calculation
- **Table Responsiveness**: Use appropriate column widths and overflow handling
- **Mobile Support**: Ensure components work on mobile devices
- **Dynamic Layouts**: Adapt layouts based on available screen space


## Custom Drive Explorer Creation Workflow

### Problem Statement
You need a custom, application-like interface to browse, organize, or interact with specific types of documents stored within a Powerhouse drive, going beyond the standard file listing.

### Prerequisites
- Powerhouse CLI (ph-cmd) installed
- A Powerhouse project initialized (ph init)
- MCP server connection available

### Step 1: Generate Drive Explorer Template
Navigate to your project root and run the generate command with the `--drive-editor` flag:

```bash
# Replace <drive-app-name> with your desired name (e.g., network-admin)
ph generate --drive-editor <drive-app-name>
```

### Step 2: Update Module Configuration
After generation, customize the module configuration in `editors/<drive-app-name>/index.ts`:

```typescript
export const module: DriveEditorModule = {
  Component: Editor,
  documentTypes: ["powerhouse/document-drive"],
  config: {
    id: "<drive-app-name>", // Use clean, simple ID
    disableExternalControls: true,
    documentToolbarEnabled: true,
    showSwitchboardLink: true,
  },
};
```

### Step 3: Customize UI Components
- **Main Explorer** (`components/DriveExplorer.tsx`): Update sidebar title and empty state messages
- **Document Creation** (`components/CreateDocument.tsx`): Customize document type filtering if needed
- **Folder Tree** (`components/FolderTree.tsx`): Customize navigation behavior
- **Editor Container** (`components/EditorContainer.tsx`): Customize toolbar actions

### Step 4: Update Powerhouse Manifest
Add the drive explorer to the `apps` section in `powerhouse.manifest.json`:

```json
{
  "apps": [
    {
      "id": "powerhouse/<drive-app-name>",
      "name": "<Display Name> Drive Explorer",
      "description": "Custom drive explorer for managing and organizing <specific use case> documents",
      "documentTypes": ["powerhouse/document-drive"]
    }
  ]
}
```

### Step 5: Update Module Exports
Ensure the drive explorer is exported in `editors/index.ts`:

```typescript
export { module as <PascalCaseName>DriveExplorer } from "./<drive-app-name>/index.js";
```

### Key Customization Points
- **Sidebar Title**: Brand the explorer for your specific use case
- **Empty State Messages**: Provide context-specific guidance
- **Document Filtering**: Filter available document types if needed
- **UI Styling**: Customize layout, colors, and spacing using TailwindCSS
- **Folder Operations**: Customize folder creation and organization behavior

### Expected Outcome
- A new directory `editors/<drive-app-name>/` with complete drive explorer implementation
- Customizable interface for browsing, creating, and managing documents within drives
- Integration with existing document editors for seamless workflow
- Proper registration in powerhouse.manifest.json as an app module

### Notes
- Drive explorers target `powerhouse/document-drive` document type
- They provide specialized interfaces for managing documents of any type within drives
- Unlike document editors (which edit specific document types), drive explorers manage collections of documents
- The generated template includes responsive layout, folder navigation, and document creation workflows


## Drag-and-Drop Implementation for Drive Explorers

### Overview
This guide explains how to add drag-and-drop file functionality to any drive explorer editor in the Powerhouse ecosystem.

### Step 1: Configure the Editor Module
In your editor's `index.ts`, add drag-and-drop configuration:

```typescript
import type { DriveEditorModule } from "@powerhousedao/reactor-browser";
import { Editor } from "./editor.js";

export const module: DriveEditorModule = {
  Component: Editor,
  documentTypes: ["your/document-type"],
  config: {
    id: "your-editor-id",
    documentTypes: [
      // List all document types that can be dropped
      "powerhouse/document-model",
      "powerhouse/app",
      // ... other types
    ],
    dragAndDrop: {
      enabled: true,  // Enable drag-and-drop functionality
    },
  },
};
```

### Step 2: Create the withDropZone HOC
Create a `utils/withDropZone.tsx` file:

```typescript
import { DropZone } from "@powerhousedao/design-system";
import type {
  ConflictResolution,
  DriveEditorProps,
  FileUploadProgressCallback,
} from "@powerhousedao/reactor-browser";
import {
  setSelectedNode,
  useOnDropFile,
  useSelectedDriveId,
} from "@powerhousedao/reactor-browser";
import type { ComponentType } from "react";

export function withDropZone<T extends DriveEditorProps>(
  WrappedComponent: ComponentType<T>,
): ComponentType<T> {
  const WithDropZoneComponent = (props: T) => {
    const driveId = useSelectedDriveId();
    const onDropFile = useOnDropFile(props.editorConfig?.documentTypes);

    const onAddFile = async (
      file: File,
      parent: any,
      onProgress?: FileUploadProgressCallback,
      resolveConflict?: ConflictResolution,
    ) => {
      return await onDropFile(file, onProgress, resolveConflict);
    };

    // Only wrap with DropZone if enabled in config
    if (props.editorConfig?.dragAndDrop?.enabled) {
      return (
        <DropZone
          onAddFile={onAddFile}
          setSelectedNode={setSelectedNode}
          driveId={driveId}
          useLocalStorage={true}
          style={{ height: "100%" }}
        >
          <WrappedComponent {...props} />
        </DropZone>
      );
    }

    return <WrappedComponent {...props} />;
  };

  WithDropZoneComponent.displayName = `withDropZone(${
    WrappedComponent.displayName || WrappedComponent.name || "Component"
  })`;

  return WithDropZoneComponent;
}
```

### Step 3: Wrap Your Base Editor Component
In your `editor.tsx`:

```typescript
import type { DriveEditorProps } from "@powerhousedao/reactor-browser";
import { useSelectedDriveDocument } from "@powerhousedao/reactor-browser";
import { withDropZone } from "./utils/withDropZone.js";

export type IProps = DriveEditorProps;

// Your base editor component
export function BaseEditor(props: IProps) {
  const [document] = useSelectedDriveDocument();
  
  return (
    <div style={{ height: "100%" }}>
      {/* Your drive explorer UI */}
    </div>
  );
}

// Wrap base editor with drop zone functionality
const BaseEditorWithDropZone = withDropZone(BaseEditor);

// Export wrapped editor
export function Editor(props: IProps) {
  return <BaseEditorWithDropZone {...props} />;
}
```

### Step 4: Install Required Dependencies
Ensure you have the following packages installed:

```json
{
  "@powerhousedao/design-system": "...",
  "@powerhousedao/reactor-browser": "..."
}
```

### How It Works

1. **Configuration Flow**: The `editorConfig` prop is passed down to the editor component containing `dragAndDrop.enabled` and `documentTypes`

2. **Conditional Rendering**: The HOC checks the config and conditionally wraps the component with `DropZone` only when enabled

3. **File Handling**:
   - `useOnDropFile` hook processes dropped files based on allowed `documentTypes`
   - Files are validated against the configured document types
   - Successful drops trigger document creation in the drive

4. **Visual Feedback**: The `DropZone` component (from design-system) provides visual feedback during drag operations (blue overlay effect)

### Key Hooks & Components

- **`useOnDropFile(documentTypes)`**: Returns a handler that processes dropped files
- **`useSelectedDriveId()`**: Gets the current drive ID for file operations
- **`setSelectedNode(node)`**: Selects/opens the dropped document after creation
- **`DropZone` component**: Provides the drag-and-drop UI wrapper with visual feedback

### Notes

- The pattern is flexible: drag-and-drop can be toggled via configuration without code changes
- Document type filtering happens at the HOC level through `editorConfig.documentTypes`
- The visual feedback (blue overlay) is handled by the `DropZone` component's internal styling
- LocalStorage is used to persist some drop zone state (`useLocalStorage={true}`)
- This pattern provides a clean separation of concerns and makes drag-and-drop functionality easy to add to any drive editor